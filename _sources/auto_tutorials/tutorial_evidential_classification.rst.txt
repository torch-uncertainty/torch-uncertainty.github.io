
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/tutorial_evidential_classification.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_tutorials_tutorial_evidential_classification.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_tutorial_evidential_classification.py:


Deep Evidential Classification on a Toy Example
===============================================

This tutorial aims to provide an introductory overview of Deep Evidential Classification (DEC) using a practical example. We demonstrate an application of DEC by tackling the toy-problem of fitting the MNIST dataset using a Multi-Layer Perceptron (MLP) neural network model. The output of the MLP is modeled as a Dirichlet distribution. The MLP is trained by minimizing the DEC loss function, composed of a Bayesian risk square error loss and a regularization term based on KL Divergence.

DEC represents an evidential approach to quantifying uncertainty in neural network classification models. This method involves introducing prior distributions over the parameters of the Categorical likelihood function. Then, the MLP model estimates the parameters of the evidential distribution.

Training a LeNet with DEC using TorchUncertainty models
-------------------------------------------------------

In this part, we train a neural network, based on the model and routines already implemented in TU.

1. Loading the utilities
~~~~~~~~~~~~~~~~~~~~~~~~

To train a LeNet with the DEC loss function using TorchUncertainty, we have to load the following utilities from TorchUncertainty:

- the Trainer from Lightning
- the model: LeNet, which lies in torch_uncertainty.models
- the classification training routine in the torch_uncertainty.routines
- the evidential objective: the DECLoss from torch_uncertainty.losses
- the datamodule that handles dataloaders & transforms: MNISTDataModule from torch_uncertainty.datamodules

We also need to define an optimizer using torch.optim, the neural network utils within torch.nn.

.. GENERATED FROM PYTHON SOURCE LINES 27-39

.. code-block:: Python

    from pathlib import Path

    import torch
    from lightning.pytorch import Trainer
    from torch import nn, optim

    from torch_uncertainty.datamodules import MNISTDataModule
    from torch_uncertainty.losses import DECLoss
    from torch_uncertainty.models.lenet import lenet
    from torch_uncertainty.routines import ClassificationRoutine









.. GENERATED FROM PYTHON SOURCE LINES 40-44

2. Creating the Optimizer Wrapper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We follow the official implementation in DEC, use the Adam optimizer
with the default learning rate of 0.001 and a step scheduler.

.. GENERATED FROM PYTHON SOURCE LINES 44-50

.. code-block:: Python

    def optim_lenet(model: nn.Module) -> dict:
        optimizer = optim.Adam(model.parameters(), lr=1e-3, weight_decay=0.005)
        exp_lr_scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)
        return {"optimizer": optimizer, "lr_scheduler": exp_lr_scheduler}









.. GENERATED FROM PYTHON SOURCE LINES 51-58

3. Creating the necessary variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the following, we need to define the root of the logs, and to
fake-parse the arguments needed for using the PyTorch Lightning Trainer. We
also use the same MNIST classification example as that used in the
original DEC paper. We only train for 3 epochs for the sake of time.

.. GENERATED FROM PYTHON SOURCE LINES 58-69

.. code-block:: Python

    trainer = Trainer(accelerator="cpu", max_epochs=3, enable_progress_bar=False)

    # datamodule
    root = Path() / "data"
    datamodule = MNISTDataModule(root=root, batch_size=128)

    model = lenet(
        in_channels=datamodule.num_channels,
        num_classes=datamodule.num_classes,
    )








.. GENERATED FROM PYTHON SOURCE LINES 70-78

4. The Loss and the Training Routine
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Next, we need to define the loss to be used during training.
After that, we define the training routine using
the single classification model training routine from
torch_uncertainty.routines.ClassificationRoutine.
In this routine, we provide the model, the DEC loss, the optimizer,
and all the default arguments.

.. GENERATED FROM PYTHON SOURCE LINES 78-88

.. code-block:: Python


    loss = DECLoss(reg_weight=1e-2)

    routine = ClassificationRoutine(
        model=model,
        num_classes=datamodule.num_classes,
        loss=loss,
        optim_recipe=optim_lenet(model),
    )








.. GENERATED FROM PYTHON SOURCE LINES 89-91

5. Gathering Everything and Training the Model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 91-95

.. code-block:: Python


    trainer.fit(model=routine, datamodule=datamodule)
    trainer.test(model=routine, datamodule=datamodule)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /opt/hostedtoolcache/Python/3.10.14/x64/lib/python3.10/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:424: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=3` in the `DataLoader` to improve performance.
    /opt/hostedtoolcache/Python/3.10.14/x64/lib/python3.10/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:424: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=3` in the `DataLoader` to improve performance.
    /opt/hostedtoolcache/Python/3.10.14/x64/lib/python3.10/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:424: The 'test_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=3` in the `DataLoader` to improve performance.
    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃        Test metric        ┃       DataLoader 0        ┃
    ┡━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
    │       test/cal/ECE        │    0.09078174829483032    │
    │       test/cal/aECE       │     0.126327782869339     │
    │       test/cls/Acc        │    0.6611999869346619     │
    │      test/cls/Brier       │    0.4177456498146057     │
    │       test/cls/NLL        │            inf            │
    │     test/cls/entropy      │    0.48079559206962585    │
    │       test/sc/AURC        │    0.10690028965473175    │
    │    test/sc/CovAt5Risk     │     0.593500018119812     │
    │    test/sc/RiskAt80Cov    │    0.25737500190734863    │
    └───────────────────────────┴───────────────────────────┘

    [{'test/cal/ECE': 0.09078174829483032, 'test/cal/aECE': 0.126327782869339, 'test/cls/Acc': 0.6611999869346619, 'test/cls/Brier': 0.4177456498146057, 'test/cls/NLL': inf, 'test/sc/AURC': 0.10690028965473175, 'test/sc/CovAt5Risk': 0.593500018119812, 'test/sc/RiskAt80Cov': 0.25737500190734863, 'test/cls/entropy': 0.48079559206962585}]



.. GENERATED FROM PYTHON SOURCE LINES 96-99

6. Testing the Model
~~~~~~~~~~~~~~~~~~~~
Now that the model is trained, let's test it on MNIST.

.. GENERATED FROM PYTHON SOURCE LINES 99-146

.. code-block:: Python


    import matplotlib.pyplot as plt
    import numpy as np
    import torchvision
    import torchvision.transforms.functional as F


    def imshow(img) -> None:
        npimg = img.numpy()
        plt.imshow(np.transpose(npimg, (1, 2, 0)))
        plt.show()


    def rotated_mnist(angle: int) -> None:
        """Rotate MNIST images and show images and confidence.

        Args:
            angle: Rotation angle in degrees.
        """
        rotated_images = F.rotate(images, angle)
        # print rotated images
        plt.axis("off")
        imshow(torchvision.utils.make_grid(rotated_images[:4, ...]))
        print("Ground truth: ", " ".join(f"{labels[j]}" for j in range(4)))

        evidence = routine(rotated_images)
        alpha = torch.relu(evidence) + 1
        strength = torch.sum(alpha, dim=1, keepdim=True)
        probs = alpha / strength
        entropy = -1 * torch.sum(probs * torch.log(probs), dim=1, keepdim=True)
        for j in range(4):
            predicted = torch.argmax(probs[j, :])
            print(
                f"Predicted digits for the image {j}: {predicted} with strength "
                f"{strength[j,0]:.3} and entropy {entropy[j,0]:.3}."
            )


    dataiter = iter(datamodule.val_dataloader())
    images, labels = next(dataiter)

    with torch.no_grad():
        routine.eval()
        rotated_mnist(0)
        rotated_mnist(45)
        rotated_mnist(90)




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_evidential_classification_001.png
   :alt: tutorial evidential classification
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_evidential_classification_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).
    Ground truth:  7 2 1 0
    Predicted digits for the image 0: 7 with strength 77.9 and entropy 0.634.
    Predicted digits for the image 1: 2 with strength 61.9 and entropy 0.734.
    Predicted digits for the image 2: 1 with strength 68.6 and entropy 0.677.
    Predicted digits for the image 3: 0 with strength 47.6 and entropy 0.9.
    Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).
    Ground truth:  7 2 1 0
    Predicted digits for the image 0: 4 with strength 21.4 and entropy 1.8.
    Predicted digits for the image 1: 0 with strength 10.0 and entropy 2.3.
    Predicted digits for the image 2: 0 with strength 10.0 and entropy 2.3.
    Predicted digits for the image 3: 0 with strength 20.2 and entropy 1.67.
    Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).
    Ground truth:  7 2 1 0
    Predicted digits for the image 0: 7 with strength 22.4 and entropy 1.8.
    Predicted digits for the image 1: 4 with strength 45.9 and entropy 1.38.
    Predicted digits for the image 2: 7 with strength 52.5 and entropy 1.41.
    Predicted digits for the image 3: 0 with strength 27.8 and entropy 1.34.




.. GENERATED FROM PYTHON SOURCE LINES 147-151

References
----------

- **Deep Evidential Classification:** Murat Sensoy, Lance Kaplan, & Melih Kandemir (2018). Evidential Deep Learning to Quantify Classification Uncertainty `NeurIPS 2018 <https://arxiv.org/pdf/1806.01768>`_.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 54.660 seconds)


.. _sphx_glr_download_auto_tutorials_tutorial_evidential_classification.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: tutorial_evidential_classification.ipynb <tutorial_evidential_classification.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: tutorial_evidential_classification.py <tutorial_evidential_classification.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: tutorial_evidential_classification.zip <tutorial_evidential_classification.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
