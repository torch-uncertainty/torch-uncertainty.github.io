
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/tutorial_pe_cifar10.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_tutorials_tutorial_pe_cifar10.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_tutorial_pe_cifar10.py:


From a Standard Classifier to a Packed-Ensemble
===============================================

This tutorial is heavily inspired by PyTorch's `Training a Classifier <https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#test-the-network-on-the-test-data>`_
tutorial.

Let's dive step by step into the process to modify a standard classifier into a
packed-ensemble classifier.

Dataset
-------

In this tutorial we will use the CIFAR10 dataset available in the torchvision
package. The CIFAR10 dataset consists of 60000 32x32 colour images in 10
classes, with 6000 images per class. There are 50000 training images and 10000
test images.

Here is an example of what the data looks like:

.. figure:: /_static/img/cifar10.png
   :alt: cifar10
   :figclass: figure-caption

   Sample of the CIFAR-10 dataset

Training an image Packed-Ensemble classifier
--------------------------------------------

Here is the outline of the process:

1. Load and normalizing the CIFAR10 training and test datasets using
   ``torchvision``
2. Define a Packed-Ensemble from a standard classifier
3. Define a loss function
4. Train the Packed-Ensemble on the training data
5. Test the Packed-Ensemble on the test data and evaluate its performance
   w.r.t. uncertainty quantification and OOD detection

1. Load and normalize CIFAR10
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 45-52

.. code-block:: Python

    import torch
    import torchvision
    import torchvision.transforms as transforms
    from torch.utils.data import DataLoader

    torch.set_num_threads(1)








.. GENERATED FROM PYTHON SOURCE LINES 53-55

The output of torchvision datasets are PILImage images of range [0, 1].
We transform them to Tensors of normalized range [-1, 1].

.. GENERATED FROM PYTHON SOURCE LINES 57-60

.. note::
    If running on Windows and you get a BrokenPipeError, try setting
    the num_worker of torch.utils.data.DataLoader() to 0.

.. GENERATED FROM PYTHON SOURCE LINES 60-97

.. code-block:: Python


    transform = transforms.Compose(
        [
            transforms.ToTensor(),
            transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),
        ]
    )

    batch_size = 4

    trainset = torchvision.datasets.CIFAR10(
        root="./data", train=True, download=True, transform=transform
    )
    trainloader = DataLoader(
        trainset, batch_size=batch_size, shuffle=True, num_workers=2
    )

    testset = torchvision.datasets.CIFAR10(
        root="./data", train=False, download=True, transform=transform
    )
    testloader = DataLoader(
        testset, batch_size=batch_size, shuffle=False, num_workers=2
    )

    classes = (
        "plane",
        "car",
        "bird",
        "cat",
        "deer",
        "dog",
        "frog",
        "horse",
        "ship",
        "truck",
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0.00/170M [00:00<?, ?B/s]      0%|          | 65.5k/170M [00:00<07:51, 362kB/s]      0%|          | 164k/170M [00:00<04:39, 609kB/s]       0%|          | 328k/170M [00:00<02:52, 984kB/s]      0%|          | 623k/170M [00:00<01:44, 1.63MB/s]      1%|          | 983k/170M [00:00<01:15, 2.24MB/s]      1%|          | 1.38M/170M [00:00<01:02, 2.72MB/s]      1%|          | 1.77M/170M [00:00<00:55, 3.02MB/s]      1%|          | 2.13M/170M [00:00<00:53, 3.15MB/s]      1%|▏         | 2.52M/170M [00:01<00:51, 3.29MB/s]      2%|▏         | 2.92M/170M [00:01<00:48, 3.43MB/s]      2%|▏         | 3.38M/170M [00:01<00:44, 3.74MB/s]      2%|▏         | 3.83M/170M [00:01<00:42, 3.91MB/s]      3%|▎         | 4.29M/170M [00:01<00:41, 4.03MB/s]      3%|▎         | 4.72M/170M [00:01<00:41, 3.96MB/s]      3%|▎         | 5.21M/170M [00:01<00:39, 4.22MB/s]      3%|▎         | 5.73M/170M [00:01<00:36, 4.46MB/s]      4%|▎         | 6.29M/170M [00:01<00:35, 4.67MB/s]      4%|▍         | 6.78M/170M [00:01<00:36, 4.52MB/s]      4%|▍         | 7.37M/170M [00:02<00:33, 4.84MB/s]      5%|▍         | 8.19M/170M [00:02<00:28, 5.64MB/s]      5%|▌         | 9.34M/170M [00:02<00:22, 7.22MB/s]      6%|▋         | 10.9M/170M [00:02<00:16, 9.67MB/s]      7%|▋         | 12.4M/170M [00:02<00:14, 11.1MB/s]      9%|▊         | 14.8M/170M [00:02<00:10, 14.8MB/s]     10%|█         | 17.5M/170M [00:02<00:08, 18.1MB/s]     12%|█▏        | 20.1M/170M [00:02<00:07, 20.3MB/s]     13%|█▎        | 22.7M/170M [00:02<00:06, 22.1MB/s]     15%|█▍        | 25.4M/170M [00:03<00:06, 23.3MB/s]     16%|█▋        | 28.0M/170M [00:03<00:05, 24.2MB/s]     18%|█▊        | 30.5M/170M [00:03<00:05, 23.7MB/s]     20%|█▉        | 33.5M/170M [00:03<00:05, 25.3MB/s]     21%|██        | 36.1M/170M [00:03<00:05, 25.6MB/s]     23%|██▎       | 38.8M/170M [00:03<00:05, 25.7MB/s]     24%|██▍       | 41.4M/170M [00:03<00:05, 25.7MB/s]     26%|██▌       | 44.0M/170M [00:03<00:04, 25.8MB/s]     27%|██▋       | 46.6M/170M [00:03<00:04, 25.6MB/s]     29%|██▉       | 49.3M/170M [00:03<00:04, 26.1MB/s]     31%|███       | 52.2M/170M [00:04<00:04, 26.8MB/s]     32%|███▏      | 55.2M/170M [00:04<00:04, 27.9MB/s]     34%|███▍      | 58.3M/170M [00:04<00:03, 28.7MB/s]     36%|███▌      | 61.5M/170M [00:04<00:03, 29.5MB/s]     38%|███▊      | 64.6M/170M [00:04<00:03, 30.1MB/s]     40%|███▉      | 67.9M/170M [00:04<00:03, 30.7MB/s]     42%|████▏     | 71.1M/170M [00:04<00:03, 31.0MB/s]     44%|████▎     | 74.4M/170M [00:04<00:03, 31.4MB/s]     46%|████▌     | 77.6M/170M [00:04<00:02, 31.8MB/s]     47%|████▋     | 80.9M/170M [00:04<00:02, 31.8MB/s]     50%|████▉     | 84.6M/170M [00:05<00:02, 32.3MB/s]     52%|█████▏    | 88.3M/170M [00:05<00:02, 33.5MB/s]     54%|█████▍    | 92.0M/170M [00:05<00:02, 34.4MB/s]     56%|█████▌    | 95.5M/170M [00:05<00:02, 33.2MB/s]     58%|█████▊    | 99.0M/170M [00:05<00:02, 33.9MB/s]     60%|██████    | 102M/170M [00:05<00:01, 34.1MB/s]      62%|██████▏   | 106M/170M [00:05<00:01, 32.9MB/s]     64%|██████▍   | 110M/170M [00:05<00:01, 33.7MB/s]     66%|██████▌   | 113M/170M [00:05<00:01, 33.8MB/s]     68%|██████▊   | 116M/170M [00:06<00:01, 32.8MB/s]     70%|███████   | 120M/170M [00:06<00:01, 33.5MB/s]     72%|███████▏  | 123M/170M [00:06<00:01, 33.6MB/s]     74%|███████▍  | 127M/170M [00:06<00:01, 33.9MB/s]     76%|███████▋  | 130M/170M [00:06<00:01, 32.9MB/s]     78%|███████▊  | 134M/170M [00:06<00:01, 33.2MB/s]     80%|████████  | 137M/170M [00:06<00:00, 33.7MB/s]     82%|████████▏ | 140M/170M [00:06<00:00, 32.8MB/s]     84%|████████▍ | 144M/170M [00:06<00:00, 33.3MB/s]     86%|████████▋ | 147M/170M [00:06<00:00, 33.7MB/s]     88%|████████▊ | 151M/170M [00:07<00:00, 32.9MB/s]     90%|█████████ | 154M/170M [00:07<00:00, 33.0MB/s]     92%|█████████▏| 157M/170M [00:07<00:00, 32.2MB/s]     94%|█████████▍| 161M/170M [00:07<00:00, 28.5MB/s]     96%|█████████▌| 164M/170M [00:07<00:00, 24.0MB/s]     98%|█████████▊| 166M/170M [00:07<00:00, 21.0MB/s]     99%|█████████▉| 169M/170M [00:07<00:00, 20.1MB/s]    100%|██████████| 170M/170M [00:07<00:00, 21.4MB/s]




.. GENERATED FROM PYTHON SOURCE LINES 98-99

Let us show some of the training images, for fun.

.. GENERATED FROM PYTHON SOURCE LINES 99-126

.. code-block:: Python


    import matplotlib.pyplot as plt

    import numpy as np

    # functions to show an image


    def imshow(img):
        img = img / 2 + 0.5  # unnormalize
        npimg = img.numpy()
        plt.figure(figsize=(10, 3))
        plt.axis("off")
        plt.imshow(np.transpose(npimg, (1, 2, 0)))
        plt.show()


    # get some random training images
    dataiter = iter(trainloader)
    images, labels = next(dataiter)

    # show images
    imshow(torchvision.utils.make_grid(images, pad_value=1))
    # print labels
    print(" ".join(f"{classes[labels[j]]:5s}" for j in range(batch_size)))





.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_pe_cifar10_001.png
   :alt: tutorial pe cifar10
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_pe_cifar10_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    car   horse deer  horse




.. GENERATED FROM PYTHON SOURCE LINES 127-131

2. Define a Packed-Ensemble from a standard classifier
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
First we define a standard classifier for CIFAR10 for reference. We will use a
convolutional neural network.

.. GENERATED FROM PYTHON SOURCE LINES 131-158

.. code-block:: Python


    import torch.nn.functional as F
    from torch import nn


    class Net(nn.Module):
        def __init__(self):
            super(Net, self).__init__()
            self.conv1 = nn.Conv2d(3, 6, 5)
            self.pool = nn.MaxPool2d(2, 2)
            self.conv2 = nn.Conv2d(6, 16, 5)
            self.fc1 = nn.Linear(16 * 5 * 5, 120)
            self.fc2 = nn.Linear(120, 84)
            self.fc3 = nn.Linear(84, 10)

        def forward(self, x):
            x = self.pool(F.relu(self.conv1(x)))
            x = self.pool(F.relu(self.conv2(x)))
            x = x.flatten(1)
            x = F.relu(self.fc1(x))
            x = F.relu(self.fc2(x))
            x = self.fc3(x)
            return x


    net = Net()








.. GENERATED FROM PYTHON SOURCE LINES 159-161

Let's modify the standard classifier into a Packed-Ensemble classifier of
parameters :math:`M=4,\ \alpha=2\text{ and }\gamma=1`.

.. GENERATED FROM PYTHON SOURCE LINES 161-201

.. code-block:: Python


    from einops import rearrange

    from torch_uncertainty.layers import PackedConv2d, PackedLinear


    class PackedNet(nn.Module):
        def __init__(self) -> None:
            super().__init__()
            M = 4
            alpha = 2
            gamma = 1
            self.conv1 = PackedConv2d(
                3, 6, 5, alpha=alpha, num_estimators=M, gamma=gamma, first=True
            )
            self.pool = nn.MaxPool2d(2, 2)
            self.conv2 = PackedConv2d(6, 16, 5, alpha=alpha, num_estimators=M, gamma=gamma)
            self.fc1 = PackedLinear(
                16 * 5 * 5, 120, alpha=alpha, num_estimators=M, gamma=gamma
            )
            self.fc2 = PackedLinear(120, 84, alpha=alpha, num_estimators=M, gamma=gamma)
            self.fc3 = PackedLinear(
                84, 10 * M, alpha=alpha, num_estimators=M, gamma=gamma, last=True
            )

            self.num_estimators = M

        def forward(self, x):
            x = self.pool(F.relu(self.conv1(x)))
            x = self.pool(F.relu(self.conv2(x)))
            x = rearrange(x, "e (m c) h w -> (m e) c h w", m=self.num_estimators)
            x = x.flatten(1)
            x = F.relu(self.fc1(x))
            x = F.relu(self.fc2(x))
            x = self.fc3(x)
            return x


    packed_net = PackedNet()








.. GENERATED FROM PYTHON SOURCE LINES 202-205

3. Define a Loss function and optimizer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Let's use a Classification Cross-Entropy loss and SGD with momentum.

.. GENERATED FROM PYTHON SOURCE LINES 205-211

.. code-block:: Python


    from torch import optim

    criterion = nn.CrossEntropyLoss()
    optimizer = optim.SGD(packed_net.parameters(), lr=0.001, momentum=0.9)








.. GENERATED FROM PYTHON SOURCE LINES 212-215

4. Train the Packed-Ensemble on the training data
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Let's train the Packed-Ensemble on the training data.

.. GENERATED FROM PYTHON SOURCE LINES 215-238

.. code-block:: Python


    for epoch in range(2):  # loop over the dataset multiple times
        running_loss = 0.0
        for i, data in enumerate(trainloader, 0):
            # get the inputs; data is a list of [inputs, labels]
            inputs, labels = data

            # zero the parameter gradients
            optimizer.zero_grad()
            # forward + backward + optimize
            outputs = packed_net(inputs)
            loss = criterion(outputs, labels.repeat(packed_net.num_estimators))
            loss.backward()
            optimizer.step()

            # print statistics
            running_loss += loss.item()
            if i % 2000 == 1999:  # print every 2000 mini-batches
                print(f"[{epoch + 1}, {i + 1:5d}] loss: {running_loss / 2000:.3f}")
                running_loss = 0.0

    print("Finished Training")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [1,  2000] loss: 2.677
    [1,  4000] loss: 2.185
    [1,  6000] loss: 2.033
    [1,  8000] loss: 1.951
    [1, 10000] loss: 1.911
    [1, 12000] loss: 1.847
    [2,  2000] loss: 1.759
    [2,  4000] loss: 1.720
    [2,  6000] loss: 1.699
    [2,  8000] loss: 1.639
    [2, 10000] loss: 1.628
    [2, 12000] loss: 1.608
    Finished Training




.. GENERATED FROM PYTHON SOURCE LINES 239-240

Save our trained model:

.. GENERATED FROM PYTHON SOURCE LINES 240-244

.. code-block:: Python


    PATH = "./cifar_packed_net.pth"
    torch.save(packed_net.state_dict(), PATH)








.. GENERATED FROM PYTHON SOURCE LINES 245-248

5. Test the Packed-Ensemble on the test data
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Let us display an image from the test set to get familiar.

.. GENERATED FROM PYTHON SOURCE LINES 248-259

.. code-block:: Python


    dataiter = iter(testloader)
    images, labels = next(dataiter)

    # print images
    imshow(torchvision.utils.make_grid(images, pad_value=1))
    print(
        "GroundTruth: ",
        " ".join(f"{classes[labels[j]]:5s}" for j in range(batch_size)),
    )




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_pe_cifar10_002.png
   :alt: tutorial pe cifar10
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_pe_cifar10_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    GroundTruth:  cat   ship  ship  plane




.. GENERATED FROM PYTHON SOURCE LINES 260-262

Next, let us load back in our saved model (note: saving and re-loading the
model wasn't necessary here, we only did it to illustrate how to do so):

.. GENERATED FROM PYTHON SOURCE LINES 262-266

.. code-block:: Python


    packed_net = PackedNet()
    packed_net.load_state_dict(torch.load(PATH))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <All keys matched successfully>



.. GENERATED FROM PYTHON SOURCE LINES 267-268

Let us see what the Packed-Ensemble thinks these examples above are:

.. GENERATED FROM PYTHON SOURCE LINES 268-281

.. code-block:: Python


    logits = packed_net(images)
    logits = rearrange(logits, "(n b) c -> b n c", n=packed_net.num_estimators)
    probs_per_est = F.softmax(logits, dim=-1)
    outputs = probs_per_est.mean(dim=1)

    _, predicted = torch.max(outputs, 1)

    print(
        "Predicted: ",
        " ".join(f"{classes[predicted[j]]:5s}" for j in range(batch_size)),
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Predicted:  cat   ship  ship  ship 




.. GENERATED FROM PYTHON SOURCE LINES 282-283

The results seem pretty good.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 3.210 seconds)


.. _sphx_glr_download_auto_tutorials_tutorial_pe_cifar10.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: tutorial_pe_cifar10.ipynb <tutorial_pe_cifar10.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: tutorial_pe_cifar10.py <tutorial_pe_cifar10.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: tutorial_pe_cifar10.zip <tutorial_pe_cifar10.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
