
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/Bayesian_Methods/tutorial_mc_dropout.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_tutorials_Bayesian_Methods_tutorial_mc_dropout.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_Bayesian_Methods_tutorial_mc_dropout.py:


Training a LeNet with Monte-Carlo Dropout
=========================================

In this tutorial, we will train a LeNet classifier on the MNIST dataset using Monte-Carlo Dropout (MC Dropout), a computationally efficient Bayesian approximation method. To estimate the predictive mean and uncertainty (variance), we perform multiple forward passes through the network with dropout layers enabled in ``train`` mode.

For more information on Monte-Carlo Dropout, we refer the reader to the following resources:

- Dropout as a Bayesian Approximation: Representing Model Uncertainty in Deep Learning `ICML 2016 <https://browse.arxiv.org/pdf/1506.02142.pdf>`_
- What Uncertainties Do We Need in Bayesian Deep Learning for Computer Vision? `NeurIPS 2017 <https://browse.arxiv.org/pdf/1703.04977.pdf>`_

Training a LeNet with MC Dropout using TorchUncertainty models and PyTorch Lightning
-------------------------------------------------------------------------------------

In this part, we train a LeNet with dropout layers, based on the model and routines already implemented in TU.

1. Loading the utilities
~~~~~~~~~~~~~~~~~~~~~~~~

First, we have to load the following utilities from TorchUncertainty:

- the TUTrainer from TorchUncertainty utils
- the datamodule handling dataloaders: MNISTDataModule from torch_uncertainty.datamodules
- the model: lenet from torch_uncertainty.models
- the MC Dropout wrapper: mc_dropout, from torch_uncertainty.models.wrappers
- the classification training & evaluation routine in the torch_uncertainty.routines
- an optimization recipe in the torch_uncertainty.optim_recipes module.

We also need import the neural network utils within `torch.nn`.

.. GENERATED FROM PYTHON SOURCE LINES 34-48

.. code-block:: Python

    from pathlib import Path

    from torch import nn

    from torch_uncertainty import TUTrainer
    from torch_uncertainty.datamodules import MNISTDataModule
    from torch_uncertainty.models import mc_dropout
    from torch_uncertainty.models.classification import lenet
    from torch_uncertainty.optim_recipes import optim_cifar10_resnet18
    from torch_uncertainty.routines import ClassificationRoutine

    MAX_EPOCHS = 1
    BATCH_SIZE = 512








.. GENERATED FROM PYTHON SOURCE LINES 49-58

2. Defining the Model and the Trainer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the following, we first create the trainer and instantiate
the datamodule that handles the MNIST dataset,
dataloaders and transforms. We create the model using the
blueprint from torch_uncertainty.models and we wrap it into an mc_dropout.
To use the mc_dropout wrapper, **make sure that you use dropout modules** and
not functionals. Moreover, **they have to be** instantiated in the __init__ method.

.. GENERATED FROM PYTHON SOURCE LINES 58-74

.. code-block:: Python


    trainer = TUTrainer(accelerator="gpu", devices=1, max_epochs=MAX_EPOCHS, enable_progress_bar=False)

    # datamodule
    root = Path("data")
    datamodule = MNISTDataModule(root=root, batch_size=BATCH_SIZE, num_workers=8)


    model = lenet(
        in_channels=datamodule.num_channels,
        num_classes=datamodule.num_classes,
        dropout_rate=0.5,
    )

    mc_model = mc_dropout(model, num_estimators=16, last_layer=False)








.. GENERATED FROM PYTHON SOURCE LINES 75-81

3. The Loss and the Training Routine
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a classification problem, and we use CrossEntropyLoss as the (negative-log-)likelihood.
We define the training routine using the classification training routine from
torch_uncertainty.routines. We provide the number of classes
the optimization recipe and tell the routine that our model is an ensemble at evaluation time.

.. GENERATED FROM PYTHON SOURCE LINES 81-90

.. code-block:: Python


    routine = ClassificationRoutine(
        num_classes=datamodule.num_classes,
        model=mc_model,
        loss=nn.CrossEntropyLoss(),
        optim_recipe=optim_cifar10_resnet18(mc_model),
        is_ensemble=True,
    )








.. GENERATED FROM PYTHON SOURCE LINES 91-97

4. Gathering Everything and Training the Model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can now train the model using the trainer. We pass the routine and the datamodule
to the fit and test methods of the trainer. It will automatically evaluate some uncertainty
metrics that you will find in the table below.

.. GENERATED FROM PYTHON SOURCE LINES 97-101

.. code-block:: Python


    trainer.fit(model=routine, datamodule=datamodule)
    results = trainer.test(model=routine, datamodule=datamodule)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ┏━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━┳━━━━━━━┓
    ┃   ┃ Name                ┃ Type                ┃ Params ┃ Mode  ┃ FLOPs ┃
    ┡━━━╇━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━╇━━━━━━━┩
    │ 0 │ ood_criterion       │ MaxSoftmaxCriterion │      0 │ train │     0 │
    │ 1 │ model               │ _MCDropout          │ 44.4 K │ train │     0 │
    │ 2 │ loss                │ CrossEntropyLoss    │      0 │ train │     0 │
    │ 3 │ format_batch_fn     │ Identity            │      0 │ train │     0 │
    │ 4 │ val_cls_metrics     │ MetricCollection    │      0 │ train │     0 │
    │ 5 │ test_cls_metrics    │ MetricCollection    │      0 │ train │     0 │
    │ 6 │ test_id_entropy     │ Entropy             │      0 │ train │     0 │
    │ 7 │ test_id_ens_metrics │ MetricCollection    │      0 │ train │     0 │
    │ 8 │ mixup               │ Identity            │      0 │ train │     0 │
    └───┴─────────────────────┴─────────────────────┴────────┴───────┴───────┘
    Trainable params: 44.4 K                                                        
    Non-trainable params: 0                                                         
    Total params: 44.4 K                                                            
    Total estimated model params size (MB): 0                                       
    Modules in train mode: 42                                                       
    Modules in eval mode: 0                                                         
    Total FLOPs: 0                                                                  
    ┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃ Test metric  ┃      Classification       ┃
    ┡━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
    │     Acc      │          74.440%          │
    │    Brier     │          0.50514          │
    │   Entropy    │          1.76962          │
    │     NLL      │          1.12038          │
    └──────────────┴───────────────────────────┘
    ┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃ Test metric  ┃        Calibration        ┃
    ┡━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
    │     ECE      │          33.854%          │
    │     aECE     │          33.854%          │
    └──────────────┴───────────────────────────┘
    ┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃ Test metric  ┃ Selective Classification  ┃
    ┡━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
    │    AUGRC     │          7.119%           │
    │     AURC     │          9.888%           │
    │  Cov@5Risk   │           nan%            │
    │  Risk@80Cov  │          17.725%          │
    └──────────────┴───────────────────────────┘
    ┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃ Test metric  ┃        Complexity         ┃
    ┡━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
    │    flops     │          4.61 G           │
    │    params    │          44.43 K          │
    └──────────────┴───────────────────────────┘




.. GENERATED FROM PYTHON SOURCE LINES 102-106

5. Testing the Model
~~~~~~~~~~~~~~~~~~~~
Now that the model is trained, let's test it on MNIST. Don't forget to call
.eval() to enable dropout at evaluation and get multiple (here 16) predictions.

.. GENERATED FROM PYTHON SOURCE LINES 106-141

.. code-block:: Python


    import matplotlib.pyplot as plt
    import numpy as np
    import torch
    import torchvision
    from einops import rearrange


    def imshow(img) -> None:
        npimg = img.numpy()
        plt.imshow(np.transpose(npimg, (1, 2, 0)))
        plt.axis("off")
        plt.tight_layout()
        plt.show()


    dataiter = iter(datamodule.val_dataloader())
    images, labels = next(dataiter)
    images = images[:6]

    # print images
    imshow(torchvision.utils.make_grid(images[:6, ...], padding=0))

    routine.eval()
    logits = rearrange(routine(images), "(m b) c -> b m c", b=6)
    probs = logits.softmax(dim=-1)


    for j in range(6):
        values, predicted = torch.max(probs[j, :], 1)
        print(
            f"MC-Dropout predictions for the image {j + 1}: ",
            " ".join([str(image_id.item()) for image_id in predicted]),
        )




.. image-sg:: /auto_tutorials/Bayesian_Methods/images/sphx_glr_tutorial_mc_dropout_001.png
   :alt: tutorial mc dropout
   :srcset: /auto_tutorials/Bayesian_Methods/images/sphx_glr_tutorial_mc_dropout_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    MC-Dropout predictions for the image 1:  7 7 7 7 7 7 7 3 7 7 7 7 7 7 7 7
    MC-Dropout predictions for the image 2:  2 1 2 6 2 2 2 2 3 2 2 2 2 2 3 2
    MC-Dropout predictions for the image 3:  1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    MC-Dropout predictions for the image 4:  0 9 0 8 1 1 3 3 9 0 0 0 0 0 8 0
    MC-Dropout predictions for the image 5:  4 1 4 1 4 6 4 4 4 4 4 4 1 4 4 4
    MC-Dropout predictions for the image 6:  1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1




.. GENERATED FROM PYTHON SOURCE LINES 142-144

Most of the time, we see that there is some disagreement between the samples of the dropout
approximation of the posterior distribution.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 3.586 seconds)


.. _sphx_glr_download_auto_tutorials_Bayesian_Methods_tutorial_mc_dropout.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: tutorial_mc_dropout.ipynb <tutorial_mc_dropout.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: tutorial_mc_dropout.py <tutorial_mc_dropout.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: tutorial_mc_dropout.zip <tutorial_mc_dropout.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
